<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>City Drift: Final Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; user-select: none; }
        
        #hud {
            position: absolute; top: 20px; left: 20px;
            color: white; z-index: 10;
            background: linear-gradient(90deg, rgba(0,0,0,0.9), transparent);
            padding: 15px; border-left: 5px solid #00d2ff; border-radius: 5px;
            pointer-events: none;
        }
        
        .stat { font-size: 20px; font-weight: bold; margin-bottom: 5px; text-shadow: 1px 1px 2px black; }
        
        #controls { 
            position: absolute; bottom: 20px; right: 20px; 
            color: rgba(255,255,255,0.8); text-align: right; font-size: 14px; 
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; pointer-events: none;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; font-weight: bold; background: rgba(0,0,0,0.8); padding: 20px;
            z-index: 200; border: 2px solid white; text-align: center;
        }
    </style>
</head>
<body>

<div id="loading">Lade Stadt & Modelle...<br><small>Benötigt: porsche.obj & sls.obj</small></div>

<div id="hud">
    <div class="stat" style="color:#00d2ff">METROPOLIS</div>
    <div class="stat">Speed: <span id="speed-text">0</span> km/h</div>
    <div class="stat" style="font-size:14px; color:#aaa">Pos: <span id="pos-text">0, 0</span></div>
</div>

<div id="controls">
    <b>W</b> Gas | <b>S</b> Bremse/Rückwärts<br>
    <b>A/D</b> Lenken | <b>SPACE</b> Drift
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
    import { OBJLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/OBJLoader.js';
    import { GUI } from 'https://cdn.skypack.dev/dat.gui';

    // ==========================================
    // === MODELL KONFIGURATION (HIER ÄNDERN) ===
    // ==========================================

    const PLAYER_FILE = 'porsche.obj'; 
    const AI_FILE = 'sls.obj'; 

    // --- SPIELER AUTO (PORSCHE) ---
    const PLAYER_OPTS = {
        scale: 2.0,
        lift: 1.1,
        rotX: 0,        // Neigung (Vorne/Hinten)
        rotY: Math.PI   // Drehung (Links/Rechts) - PI = 180 Grad
    };

    // --- AI AUTO (SLS) ---
    const AI_OPTS = {
        scale: 2.0,
        lift: 1.1,
        rotX: -Math.PI / 2, // -90 Grad (Fix für "Nase nach unten")
        rotY: Math.PI       // 180 Grad (Fix für "Falsch herum")
    };

    // ==========================================

    // STADT CONFIG
    const BLOCK_SIZE = 80;    
    const STREET_WIDTH = 40;  
    const CITY_SIZE = 12;     
    const PARK_CHANCE = 0.3;  

    // Globale Variablen
    let scene, camera, renderer;
    let playerGroup, carModel, loadedCarMesh; 
    let tires = [], particles = [];
    let colliders = []; 
    let aiCars = [];    
    let aiCarTemplate = null; 

    // Physik
    let speed = 0;
    let maxSpeed = 2.2; 
    let acceleration = 0.015; 
    let friction = 0.98; 
    let turnSpeed = 0.045;
    let currentDriftAngle = 0;
    
    let keys = { w:false, a:false, s:false, d:false, space:false };

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111); 
        scene.fog = new THREE.Fog(0x111111, 50, 700);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffeebb, 0.8);
        dirLight.position.set(200, 500, 300);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.left = -600; dirLight.shadow.camera.right = 600;
        dirLight.shadow.camera.top = 600; dirLight.shadow.camera.bottom = -600;
        scene.add(dirLight);

        createCity();
        loadAssets();
        
        initGUI();

        window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; if(e.code === 'Space') keys.space = true; if(e.key.toLowerCase() === 'r') location.reload(); });
        window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; if(e.code === 'Space') keys.space = false; });
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    }

    function initGUI() {
        const gui = new GUI();
        
        // Spieler Controls
        const pFolder = gui.addFolder('Spieler (Porsche)');
        pFolder.add(PLAYER_OPTS, 'scale', 0.1, 5.0).onChange(v => { if(loadedCarMesh) loadedCarMesh.scale.set(v,v,v); });
        pFolder.add(PLAYER_OPTS, 'lift', -2, 5).onChange(v => { if(loadedCarMesh) loadedCarMesh.position.y = v; });
        pFolder.add(PLAYER_OPTS, 'rotY', 0, 6.28).step(0.1).name('Drehung Y').onChange(v => { if(loadedCarMesh) loadedCarMesh.rotation.y = v; });
        pFolder.open();

        // AI Controls
        const aiFolder = gui.addFolder('AI (SLS)');
        aiFolder.add(AI_OPTS, 'scale', 0.1, 5.0).onChange(updateAIModels);
        aiFolder.add(AI_OPTS, 'lift', -2, 5).onChange(updateAIModels);
        aiFolder.add(AI_OPTS, 'rotX', -6.28, 6.28).step(0.1).name('Nase (X)').onChange(updateAIModels);
        aiFolder.add(AI_OPTS, 'rotY', 0, 6.28).step(0.1).name('Drehung (Y)').onChange(updateAIModels);
        aiFolder.open();
    }

    // Funktion um ALLE AI Autos live zu updaten
    function updateAIModels() {
        aiCars.forEach(group => {
            // Wir müssen das Mesh im Inneren der Gruppe finden
            group.children.forEach(child => {
                if (child.isMesh || child.type === 'Group') { // Das geladene Modell
                    child.scale.set(AI_OPTS.scale, AI_OPTS.scale, AI_OPTS.scale);
                    child.position.y = AI_OPTS.lift;
                    child.rotation.x = AI_OPTS.rotX;
                    // Rotation Y ist tricky, weil die Group sich dreht. Wir addieren es als Offset.
                    // Wir können child.rotation.y setzen, das ist relativ zur Fahrrichtung.
                    child.rotation.y = AI_OPTS.rotY;
                }
            });
        });
    }

    function loadAssets() {
        playerGroup = new THREE.Group();
        carModel = new THREE.Group();
        const startOffset = (BLOCK_SIZE + STREET_WIDTH) / 2;
        playerGroup.position.set(startOffset, 0.5, startOffset);
        playerGroup.add(carModel);
        scene.add(playerGroup);

        const loader = new OBJLoader();

        // 1. SPIELER LADEN
        loader.load(PLAYER_FILE, (object) => {
            loadedCarMesh = object;
            object.scale.set(PLAYER_OPTS.scale, PLAYER_OPTS.scale, PLAYER_OPTS.scale);
            object.position.y = PLAYER_OPTS.lift;
            object.rotation.y = PLAYER_OPTS.rotY;
            
            const paint = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.7, roughness: 0.2 });
            object.traverse(c => { if(c.isMesh) { c.material = paint; c.castShadow = true; }});
            carModel.add(object);
            
            let t1 = new THREE.Object3D(); t1.position.set(-1.5,0,1.5); carModel.add(t1); tires.push(t1);
            let t2 = new THREE.Object3D(); t2.position.set(1.5,0,1.5); carModel.add(t2); tires.push(t2);

            loadAICar(loader);

        }, undefined, () => {
            console.error("Player OBJ not found");
            const box = new THREE.Mesh(new THREE.BoxGeometry(2,1,4), new THREE.MeshStandardMaterial({color:'red'}));
            carModel.add(box);
            loadAICar(loader);
        });
    }

    function loadAICar(loader) {
        loader.load(AI_FILE, (object) => {
            document.getElementById('loading').style.display = 'none';
            console.log("AI SLS Loaded");
            
            // AI Material (Silber)
            const aiPaint = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.6, roughness: 0.3 });
            object.traverse(c => { if(c.isMesh) { c.material = aiPaint; c.castShadow = true; }});

            aiCarTemplate = object; // Template speichern
            spawnTraffic(12);

        }, undefined, () => {
            document.getElementById('loading').innerText = "SLS.obj fehlt! Nutze Boxen.";
            setTimeout(() => { document.getElementById('loading').style.display = 'none'; spawnTraffic(12); }, 2000);
        });
    }

    function createCity() {
        const groundGeo = new THREE.PlaneGeometry(3000, 3000);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const buildingGeo = new THREE.BoxGeometry(1, 1, 1); 
        const buildingMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4 });
        
        const totalCellSize = BLOCK_SIZE + STREET_WIDTH;

        for (let x = -CITY_SIZE/2; x < CITY_SIZE/2; x++) {
            for (let z = -CITY_SIZE/2; z < CITY_SIZE/2; z++) {
                const posX = x * totalCellSize;
                const posZ = z * totalCellSize;

                if (Math.random() < PARK_CHANCE) {
                    createPark(posX, posZ);
                } else {
                    createBuilding(posX, posZ, buildingGeo, buildingMat);
                }
                createZebraCrossing(posX + totalCellSize/2, posZ); 
                createZebraCrossing(posX, posZ + totalCellSize/2); 
            }
        }
    }

    function createBuilding(x, z, geo, mat) {
        const height = Math.random() * 80 + 30;
        const building = new THREE.Mesh(geo, mat);
        building.position.set(x, height/2, z);
        building.scale.set(BLOCK_SIZE, height, BLOCK_SIZE);
        building.castShadow = true;
        building.receiveShadow = true;
        scene.add(building);

        if(Math.random()>0.3) {
            const winGeo = new THREE.BoxGeometry(BLOCK_SIZE+0.5, height/2, BLOCK_SIZE+0.5);
            const winMat = new THREE.MeshBasicMaterial({color: 0xffffaa, transparent:true, opacity:0.1});
            const wins = new THREE.Mesh(winGeo, winMat);
            wins.position.copy(building.position);
            scene.add(wins);
        }
        colliders.push({ x: x, z: z, w: BLOCK_SIZE, d: BLOCK_SIZE, type: 'building' });
        
        const sidewalk = new THREE.Mesh(new THREE.BoxGeometry(BLOCK_SIZE + 4, 0.4, BLOCK_SIZE + 4), new THREE.MeshStandardMaterial({ color: 0x666666 }));
        sidewalk.position.set(x, 0.2, z);
        scene.add(sidewalk);
    }

    function createPark(x, z) {
        const parkGeo = new THREE.BoxGeometry(BLOCK_SIZE, 0.5, BLOCK_SIZE);
        const parkMat = new THREE.MeshStandardMaterial({ color: 0x228822 });
        const parkBase = new THREE.Mesh(parkGeo, parkMat);
        parkBase.position.set(x, 0.25, z);
        parkBase.receiveShadow = true;
        scene.add(parkBase);

        const trunkGeo = new THREE.CylinderGeometry(0.8, 1, 3);
        const trunkMat = new THREE.MeshStandardMaterial({color:0x553311});
        const leafGeo = new THREE.DodecahedronGeometry(3);
        const leafMat = new THREE.MeshStandardMaterial({color:0x116611});

        for(let i=0; i<8; i++) { 
            const tree = new THREE.Group();
            const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.position.y = 1.5;
            const leaf = new THREE.Mesh(leafGeo, leafMat); leaf.position.y = 4.5;
            tree.add(trunk); tree.add(leaf);
            const tx = (Math.random()-0.5) * (BLOCK_SIZE - 5);
            const tz = (Math.random()-0.5) * (BLOCK_SIZE - 5);
            tree.position.set(x + tx, 0, z + tz);
            tree.castShadow = true;
            scene.add(tree);
        }

        const fenceH = 2.5;
        const fenceThick = 1;
        const fenceMat = new THREE.MeshStandardMaterial({ color: 0x554433 }); 
        colliders.push({ x: x, z: z, w: BLOCK_SIZE, d: BLOCK_SIZE, type: 'fence' });

        const half = BLOCK_SIZE / 2;
        const walls = [
            { pos: [x, fenceH/2, z-half], scale: [BLOCK_SIZE, fenceH, fenceThick] }, 
            { pos: [x, fenceH/2, z+half], scale: [BLOCK_SIZE, fenceH, fenceThick] }, 
            { pos: [x-half, fenceH/2, z], scale: [fenceThick, fenceH, BLOCK_SIZE] }, 
            { pos: [x+half, fenceH/2, z], scale: [fenceThick, fenceH, BLOCK_SIZE] }  
        ];
        walls.forEach(w => {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), fenceMat);
            wall.position.set(...w.pos); wall.scale.set(...w.scale); wall.castShadow = true; scene.add(wall);
        });
    }

    function createZebraCrossing(x, z) {
        const group = new THREE.Group();
        const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const geo = new THREE.PlaneGeometry(3, 12);
        for(let i=-2; i<=2; i++) {
            const stripe = new THREE.Mesh(geo, mat);
            stripe.rotation.x = -Math.PI/2;
            stripe.position.set(i*5, 0.05, 0); 
            group.add(stripe);
        }
        group.position.set(x, 0, z);
        scene.add(group);
    }

    function spawnTraffic(count) {
        if (!aiCarTemplate && !document.getElementById('loading').innerText.includes('Box')) return; 

        for(let i=0; i<count; i++) {
            let aiMesh;
            const aiGroup = new THREE.Group(); // Wrapper für Bewegung

            if (aiCarTemplate) {
                aiMesh = aiCarTemplate.clone();
                // Wende Config an
                aiMesh.scale.set(AI_OPTS.scale, AI_OPTS.scale, AI_OPTS.scale);
                aiMesh.position.y = AI_OPTS.lift;
                aiMesh.rotation.x = AI_OPTS.rotX;
                aiMesh.rotation.y = AI_OPTS.rotY;
            } else {
                aiMesh = new THREE.Mesh(new THREE.BoxGeometry(2,1.5,4.5), new THREE.MeshStandardMaterial({color: 'blue'}));
            }
            aiGroup.add(aiMesh);

            const totalSize = BLOCK_SIZE + STREET_WIDTH;
            const gx = Math.floor(Math.random() * CITY_SIZE) - CITY_SIZE/2;
            const gz = Math.floor(Math.random() * CITY_SIZE) - CITY_SIZE/2;
            
            const isHorizontal = Math.random() > 0.5;
            let x, z, rot;
            const laneOffset = 10; 

            if (isHorizontal) {
                x = gx * totalSize;
                z = gz * totalSize + totalSize/2 + laneOffset; 
                rot = -Math.PI/2; 
            } else {
                x = gx * totalSize + totalSize/2 - laneOffset; 
                z = gz * totalSize;
                rot = Math.PI; // Nach unten (+Z)
            }

            aiGroup.position.set(x, 0, z); // Höhe ist im Mesh definiert
            aiGroup.rotation.y = rot;
            aiGroup.userData = { speed: 0.6 + Math.random() * 0.4 };
            scene.add(aiGroup);
            aiCars.push(aiGroup);
        }
    }

    function updateAI() {
        const raycaster = new THREE.Raycaster();
        const totalSize = BLOCK_SIZE + STREET_WIDTH;

        aiCars.forEach(ai => {
            const forward = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), ai.rotation.y);
            raycaster.set(ai.position, forward);
            const hitsPlayer = raycaster.intersectObject(playerGroup, true);
            let blocked = false;
            if (hitsPlayer.length > 0 && hitsPlayer[0].distance < 15) blocked = true;

            if (!blocked) ai.position.add(forward.multiplyScalar(ai.userData.speed));

            const centerOffset = totalSize / 2;
            const relX = (ai.position.x + 10000 + centerOffset) % totalSize; 
            const relZ = (ai.position.z + 10000 + centerOffset) % totalSize;
            const tolerance = 2.0; 
            const atIntersectionX = relX < tolerance || relX > totalSize - tolerance;
            const atIntersectionZ = relZ < tolerance || relZ > totalSize - tolerance;

            if (atIntersectionX && atIntersectionZ && Math.random() < 0.05) {
                ai.rotation.y += Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
            }
            
            const limit = (CITY_SIZE * totalSize) / 2;
            if (ai.position.x > limit) ai.position.x = -limit + 10;
            if (ai.position.x < -limit) ai.position.x = limit - 10;
            if (ai.position.z > limit) ai.position.z = -limit + 10;
            if (ai.position.z < -limit) ai.position.z = limit - 10;
        });
    }

    function spawnSmoke(pos) {
        if(Math.random()>0.3)return; 
        const p=new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5),new THREE.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.4}));
        p.position.copy(pos); p.position.y=0.2; 
        p.rotation.set(Math.random(), Math.random(), Math.random());
        scene.add(p); particles.push({mesh:p, life:1.0});
    }

    function animate() {
        requestAnimationFrame(animate);

        document.getElementById('speed-text').innerText = Math.abs(Math.floor(speed * 120));
        document.getElementById('pos-text').innerText = `${Math.round(playerGroup.position.x)}, ${Math.round(playerGroup.position.z)}`;

        if (keys.w) speed += acceleration;
        else if (keys.s) speed -= acceleration;
        else speed *= friction;

        if (speed > maxSpeed) speed = maxSpeed;
        if (speed < -0.8) speed = -0.8;

        if (Math.abs(speed) > 0.05) {
            const dir = speed > 0 ? 1 : -1;
            if(keys.a) playerGroup.rotation.y += turnSpeed * dir;
            if(keys.d) playerGroup.rotation.y -= turnSpeed * dir;
        }

        // Bewegung
        const velocity = new THREE.Vector3(0, 0, -speed).applyAxisAngle(new THREE.Vector3(0,1,0), playerGroup.rotation.y);
        const newPos = playerGroup.position.clone().add(velocity);

        let collision = false;
        const carSize = 2.5; 
        for (let b of colliders) {
            const bMinX = b.x - b.w/2; const bMaxX = b.x + b.w/2;
            const bMinZ = b.z - b.d/2; const bMaxZ = b.z + b.d/2;
            if (newPos.x + carSize > bMinX && newPos.x - carSize < bMaxX && newPos.z + carSize > bMinZ && newPos.z - carSize < bMaxZ) {
                collision = true; break;
            }
        }

        if (collision) { speed = -speed * 0.5; } else { playerGroup.position.copy(newPos); }

        let targetAngle = 0;
        if (keys.space && Math.abs(speed) > 0.5) {
            if (keys.a) targetAngle = 0.5; else if (keys.d) targetAngle = -0.5;
            tires.forEach(t => { const p=new THREE.Vector3(); t.getWorldPosition(p); spawnSmoke(p); });
            speed *= 0.99;
        }
        currentDriftAngle = THREE.MathUtils.lerp(currentDriftAngle, targetAngle, 0.1);
        carModel.rotation.y = currentDriftAngle;

        updateAI();

        const relativeCamOffset = new THREE.Vector3(0, 8, 20); 
        const cameraOffset = relativeCamOffset.applyMatrix4(playerGroup.matrixWorld);
        camera.position.lerp(cameraOffset, 0.1);
        const lookAtTarget = new THREE.Vector3(0, 2, -10); 
        lookAtTarget.applyMatrix4(playerGroup.matrixWorld);
        camera.lookAt(lookAtTarget);

        for(let i=particles.length-1; i>=0; i--) { 
            let p = particles[i]; p.life-=0.02; p.mesh.position.y+=0.05; 
            p.mesh.scale.multiplyScalar(1.05); p.mesh.material.opacity=p.life*0.5; 
            if(p.life<=0){ scene.remove(p.mesh); particles.splice(i,1); }
        }

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
