<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>City Drift: Battle Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; user-select: none; }
        
        #hud {
            position: absolute; top: 20px; left: 20px;
            color: white; z-index: 10;
            background: linear-gradient(90deg, rgba(0,0,0,0.9), transparent);
            padding: 15px; border-left: 5px solid #00d2ff; border-radius: 5px;
            pointer-events: none;
        }
        
        .stat { font-size: 20px; font-weight: bold; margin-bottom: 5px; text-shadow: 1px 1px 2px black; }
        #hp-bar { width: 200px; height: 20px; background: #333; margin-top: 5px; border: 1px solid white; }
        #hp-fill { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s, background 0.2s; }
        
        #controls { 
            position: absolute; bottom: 20px; right: 20px; 
            color: rgba(255,255,255,0.8); text-align: right; font-size: 14px; 
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; pointer-events: none;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; font-weight: bold; background: rgba(0,0,0,0.8); padding: 20px;
            z-index: 200; border: 2px solid white; text-align: center;
        }

        #gameover {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10,10,10,0.95); color: white;
            padding: 40px; border: 4px solid #ff0000; text-align: center;
            z-index: 100; box-shadow: 0 0 50px rgba(255,0,0,0.6);
        }
        
        button {
            background: #ff0000; color: white; border: none; padding: 15px 40px;
            font-size: 20px; font-weight: bold; cursor: pointer; margin-top: 20px;
            text-transform: uppercase; transform: skew(-10deg);
        }
        button:hover { background: white; color: red; }
    </style>
</head>
<body>

<div id="loading">Lade Battle Zone...<br><small>Benötigt: porsche.obj & sls.obj</small></div>

<div id="hud">
    <div class="stat" style="color:#00d2ff">METROPOLIS BATTLE</div>
    <div class="stat">Speed: <span id="speed-text">0</span> km/h</div>
    <div class="stat">Health:</div>
    <div id="hp-bar"><div id="hp-fill"></div></div>
</div>

<div id="controls">
    <b>W</b> Gas | <b>S</b> Bremse/Rückwärts<br>
    <b>A/D</b> Lenken | <b>SPACE</b> Drift<br>
    Ramme Autos um den Kampf zu starten!
</div>

<div id="gameover">
    <h1 style="margin-top:0; color:#ff0000; font-style:italic;">GAME OVER</h1>
    <p id="gameover-msg">Du wurdest zerstört.</p>
    <button onclick="location.reload()">Neustart</button>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
    import { OBJLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/OBJLoader.js';
    import { GUI } from 'https://cdn.skypack.dev/dat.gui';

    // === EINSTELLUNGEN ===
    const PLAYER_FILE = 'porsche.obj'; 
    const AI_FILE = 'sls.obj'; 

    const PLAYER_OPTS = { scale: 2.0, lift: 1.1, rotX: 0, rotY: Math.PI };
    const AI_OPTS = { scale: 2.0, lift: 1.1, rotX: -Math.PI / 2, rotY: Math.PI };

    // STADT CONFIG
    const BLOCK_SIZE = 80;    
    const STREET_WIDTH = 40;  
    const CITY_SIZE = 12;     
    const PARK_CHANCE = 0.3;  

    // Globale Variablen
    let scene, camera, renderer;
    let playerGroup, carModel, loadedCarMesh; 
    let tires = [], particles = [], bullets = [];
    let colliders = []; 
    let aiCars = [];    
    let aiCarTemplate = null; 

    // Physik & Gameplay
    let speed = 0;
    let maxSpeed = 2.2; 
    let acceleration = 0.015; 
    let friction = 0.98; 
    let turnSpeed = 0.045;
    let currentDriftAngle = 0;
    
    let playerHealth = 100;
    let isGameOver = false;
    
    let keys = { w:false, a:false, s:false, d:false, space:false };

    // Debug GUI
    const params = { scale: PLAYER_OPTS.scale, lift: PLAYER_OPTS.lift, rotationY: 180 };

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505); // Dunkler für Battle-Atmosphäre
        scene.fog = new THREE.Fog(0x050505, 50, 700);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffeebb, 0.8);
        dirLight.position.set(200, 500, 300);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.left = -600; dirLight.shadow.camera.right = 600;
        dirLight.shadow.camera.top = 600; dirLight.shadow.camera.bottom = -600;
        scene.add(dirLight);

        createCity();
        loadAssets();
        initGUI();

        window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; if(e.code === 'Space') keys.space = true; if(e.key.toLowerCase() === 'r') location.reload(); });
        window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; if(e.code === 'Space') keys.space = false; });
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    }

    function initGUI() {
        const gui = new GUI();
        const pFolder = gui.addFolder('Spieler Setup');
        pFolder.add(PLAYER_OPTS, 'scale', 0.1, 5.0).onChange(v => { if(loadedCarMesh) loadedCarMesh.scale.set(v,v,v); });
        pFolder.add(PLAYER_OPTS, 'lift', -2, 5).onChange(v => { if(loadedCarMesh) loadedCarMesh.position.y = v; });
        pFolder.add(PLAYER_OPTS, 'rotY', 0, 6.28).step(0.1).name('Drehung Y').onChange(v => { if(loadedCarMesh) loadedCarMesh.rotation.y = v; });
        
        const aiFolder = gui.addFolder('AI Setup');
        aiFolder.add(AI_OPTS, 'scale', 0.1, 5.0).onChange(updateAIModels);
        aiFolder.add(AI_OPTS, 'lift', -2, 5).onChange(updateAIModels);
        aiFolder.add(AI_OPTS, 'rotX', -6.28, 6.28).step(0.1).name('Nase (X)').onChange(updateAIModels);
        aiFolder.add(AI_OPTS, 'rotY', 0, 6.28).step(0.1).name('Drehung (Y)').onChange(updateAIModels);
    }

    function updateAIModels() {
        aiCars.forEach(group => {
            group.children.forEach(child => {
                if (child.isMesh || child.type === 'Group') { 
                    child.scale.set(AI_OPTS.scale, AI_OPTS.scale, AI_OPTS.scale);
                    child.position.y = AI_OPTS.lift;
                    child.rotation.x = AI_OPTS.rotX;
                    child.rotation.y = AI_OPTS.rotY;
                }
            });
        });
    }

    function loadAssets() {
        playerGroup = new THREE.Group();
        carModel = new THREE.Group();
        const startOffset = (BLOCK_SIZE + STREET_WIDTH) / 2;
        playerGroup.position.set(startOffset, 0.5, startOffset);
        playerGroup.add(carModel);
        scene.add(playerGroup);

        const loader = new OBJLoader();

        // Spieler
        loader.load(PLAYER_FILE, (object) => {
            loadedCarMesh = object;
            object.scale.set(PLAYER_OPTS.scale, PLAYER_OPTS.scale, PLAYER_OPTS.scale);
            object.position.y = PLAYER_OPTS.lift;
            object.rotation.y = PLAYER_OPTS.rotY;
            const paint = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.7, roughness: 0.2 });
            object.traverse(c => { if(c.isMesh) { c.material = paint; c.castShadow = true; }});
            carModel.add(object);
            let t1 = new THREE.Object3D(); t1.position.set(-1.5,0,1.5); carModel.add(t1); tires.push(t1);
            let t2 = new THREE.Object3D(); t2.position.set(1.5,0,1.5); carModel.add(t2); tires.push(t2);
            
            // AI laden
            loadAICar(loader);
        }, undefined, () => {
            const box = new THREE.Mesh(new THREE.BoxGeometry(2,1,4), new THREE.MeshStandardMaterial({color:'red'})); carModel.add(box);
            loadAICar(loader);
        });
    }

    function loadAICar(loader) {
        loader.load(AI_FILE, (object) => {
            document.getElementById('loading').style.display = 'none';
            const aiPaint = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.6, roughness: 0.3 });
            object.traverse(c => { if(c.isMesh) { c.material = aiPaint; c.castShadow = true; }});
            aiCarTemplate = object;
            spawnTraffic(15);
        }, undefined, () => {
            document.getElementById('loading').innerText = "SLS.obj fehlt! Nutze Boxen.";
            setTimeout(() => { document.getElementById('loading').style.display = 'none'; spawnTraffic(15); }, 2000);
        });
    }

    // --- STADT ---
    function createCity() {
        const groundGeo = new THREE.PlaneGeometry(3000, 3000);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const buildingGeo = new THREE.BoxGeometry(1, 1, 1); 
        const buildingMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4 });
        const totalCellSize = BLOCK_SIZE + STREET_WIDTH;

        for (let x = -CITY_SIZE/2; x < CITY_SIZE/2; x++) {
            for (let z = -CITY_SIZE/2; z < CITY_SIZE/2; z++) {
                const posX = x * totalCellSize;
                const posZ = z * totalCellSize;
                if (Math.random() < PARK_CHANCE) createPark(posX, posZ);
                else createBuilding(posX, posZ, buildingGeo, buildingMat);
                createZebraCrossing(posX + totalCellSize/2, posZ); 
                createZebraCrossing(posX, posZ + totalCellSize/2); 
            }
        }
    }

    function createBuilding(x, z, geo, mat) {
        const height = Math.random() * 80 + 30;
        const building = new THREE.Mesh(geo, mat);
        building.position.set(x, height/2, z);
        building.scale.set(BLOCK_SIZE, height, BLOCK_SIZE);
        building.castShadow = true; building.receiveShadow = true;
        scene.add(building);
        colliders.push({ x: x, z: z, w: BLOCK_SIZE, d: BLOCK_SIZE });
        const sidewalk = new THREE.Mesh(new THREE.BoxGeometry(BLOCK_SIZE + 4, 0.4, BLOCK_SIZE + 4), new THREE.MeshStandardMaterial({ color: 0x666666 }));
        sidewalk.position.set(x, 0.2, z);
        scene.add(sidewalk);
    }

    function createPark(x, z) {
        const parkGeo = new THREE.BoxGeometry(BLOCK_SIZE, 0.5, BLOCK_SIZE);
        const parkMat = new THREE.MeshStandardMaterial({ color: 0x228822 });
        const parkBase = new THREE.Mesh(parkGeo, parkMat);
        parkBase.position.set(x, 0.25, z);
        parkBase.receiveShadow = true;
        scene.add(parkBase);
        const trunkGeo = new THREE.CylinderGeometry(0.8, 1, 3);
        const trunkMat = new THREE.MeshStandardMaterial({color:0x553311});
        const leafGeo = new THREE.DodecahedronGeometry(3);
        const leafMat = new THREE.MeshStandardMaterial({color:0x116611});
        for(let i=0; i<8; i++) { 
            const tree = new THREE.Group();
            const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.position.y = 1.5;
            const leaf = new THREE.Mesh(leafGeo, leafMat); leaf.position.y = 4.5;
            tree.add(trunk); tree.add(leaf);
            tree.position.set(x + (Math.random()-0.5)*(BLOCK_SIZE-5), 0, z + (Math.random()-0.5)*(BLOCK_SIZE-5));
            tree.castShadow = true; scene.add(tree);
        }
        colliders.push({ x: x, z: z, w: BLOCK_SIZE, d: BLOCK_SIZE });
        // Zäune
        const fenceH = 2.5; const fenceThick = 1; const fenceMat = new THREE.MeshStandardMaterial({ color: 0x554433 }); 
        const half = BLOCK_SIZE / 2;
        const walls = [[x, fenceH/2, z-half, BLOCK_SIZE, fenceThick], [x, fenceH/2, z+half, BLOCK_SIZE, fenceThick], [x-half, fenceH/2, z, fenceThick, BLOCK_SIZE], [x+half, fenceH/2, z, fenceThick, BLOCK_SIZE]];
        walls.forEach(w => {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(w[3]==BLOCK_SIZE?BLOCK_SIZE:1, fenceH, w[4]==BLOCK_SIZE?BLOCK_SIZE:1), fenceMat);
            wall.position.set(w[0], w[1], w[2]); wall.castShadow=true; scene.add(wall);
        });
    }

    function createZebraCrossing(x, z) {
        const group = new THREE.Group(); const mat = new THREE.MeshBasicMaterial({ color: 0xffffff }); const geo = new THREE.PlaneGeometry(3, 12);
        for(let i=-2; i<=2; i++) { const stripe = new THREE.Mesh(geo, mat); stripe.rotation.x = -Math.PI/2; stripe.position.set(i*5, 0.05, 0); group.add(stripe); }
        group.position.set(x, 0, z); scene.add(group);
    }

    // --- AI & TRAFFIC & COMBAT ---
    function spawnTraffic(count) {
        if (!aiCarTemplate && !document.getElementById('loading').innerText.includes('Box')) return; 
        for(let i=0; i<count; i++) {
            let aiMesh;
            const aiGroup = new THREE.Group();
            if (aiCarTemplate) {
                aiMesh = aiCarTemplate.clone();
                aiMesh.scale.set(AI_OPTS.scale, AI_OPTS.scale, AI_OPTS.scale);
                aiMesh.position.y = AI_OPTS.lift;
                aiMesh.rotation.x = AI_OPTS.rotX;
                aiMesh.rotation.y = AI_OPTS.rotY;
            } else { aiMesh = new THREE.Mesh(new THREE.BoxGeometry(2,1.5,4.5), new THREE.MeshStandardMaterial({color: 'blue'})); }
            aiGroup.add(aiMesh);

            const totalSize = BLOCK_SIZE + STREET_WIDTH;
            const gx = Math.floor(Math.random() * CITY_SIZE) - CITY_SIZE/2;
            const gz = Math.floor(Math.random() * CITY_SIZE) - CITY_SIZE/2;
            const isHorizontal = Math.random() > 0.5;
            let x, z, rot;
            const laneOffset = 10; 

            if (isHorizontal) { x = gx * totalSize; z = gz * totalSize + totalSize/2 + laneOffset; rot = -Math.PI/2; } 
            else { x = gx * totalSize + totalSize/2 - laneOffset; z = gz * totalSize; rot = Math.PI; }

            aiGroup.position.set(x, 0, z); aiGroup.rotation.y = rot;
            
            // KAMPF WERTE
            aiGroup.userData = { 
                speed: 0.6 + Math.random() * 0.4, 
                state: 'drive', // 'drive' or 'attack'
                lastShot: 0,
                velocity: new THREE.Vector3(0,0,0) // Für Bounce Physik
            };
            scene.add(aiGroup);
            aiCars.push(aiGroup);
        }
    }

    function updateAI() {
        const raycaster = new THREE.Raycaster();
        const totalSize = BLOCK_SIZE + STREET_WIDTH;

        aiCars.forEach(ai => {
            // Physik Update (Bounce dämpfen)
            ai.position.add(ai.userData.velocity);
            ai.userData.velocity.multiplyScalar(0.9); // Reibung

            // --- STATUS: DRIVE ---
            if (ai.userData.state === 'drive') {
                const forward = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), ai.rotation.y);
                const moveDir = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), ai.rotation.y);

                // Kollisions-Check (Raycast)
                raycaster.set(ai.position, moveDir);
                const hitsPlayer = raycaster.intersectObject(playerGroup, true);
                let blocked = false;
                if (hitsPlayer.length > 0 && hitsPlayer[0].distance < 15) blocked = true;

                if (!blocked) {
                    ai.position.add(moveDir.multiplyScalar(ai.userData.speed));
                }

                // Kreuzung
                const centerOffset = totalSize / 2;
                const relX = (ai.position.x + 10000 + centerOffset) % totalSize; 
                const relZ = (ai.position.z + 10000 + centerOffset) % totalSize;
                const tolerance = 2.0; 
                if ((relX < tolerance || relX > totalSize - tolerance) && (relZ < tolerance || relZ > totalSize - tolerance) && Math.random() < 0.05) {
                    ai.rotation.y += Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
                }
                
                // Endlos Loop
                const limit = (CITY_SIZE * totalSize) / 2;
                if (ai.position.x > limit) ai.position.x = -limit + 10;
                if (ai.position.x < -limit) ai.position.x = limit - 10;
                if (ai.position.z > limit) ai.position.z = -limit + 10;
                if (ai.position.z < -limit) ai.position.z = limit - 10;
            } 
            
            // --- STATUS: ATTACK (Aggro nach Crash) ---
            else if (ai.userData.state === 'attack') {
                // Zur Spielerposition drehen
                ai.lookAt(playerGroup.position.x, ai.position.y, playerGroup.position.z);
                // WICHTIG: Das Modell ist um 180 gedreht, lookAt dreht "Z-Forward". 
                // Da wir das Modell auch gedreht haben, könnte das passen oder invertiert sein.
                // In diesem Fall drehen wir es einfach um PI extra, falls es falsch rum schaut
                ai.rotation.y += Math.PI;

                // Schießen
                const now = Date.now();
                if (now - ai.userData.lastShot > 800) { // Feuerrate
                    shoot(ai.position, playerGroup.position);
                    ai.userData.lastShot = now;
                }
            }
        });
    }

    function shoot(from, to) {
        const bulletGeo = new THREE.SphereGeometry(0.5);
        const bulletMat = new THREE.MeshBasicMaterial({color: 0xff0000});
        const bullet = new THREE.Mesh(bulletGeo, bulletMat);
        bullet.position.copy(from);
        bullet.position.y += 1.5; // Höhe
        
        // Richtung berechnen
        const direction = new THREE.Vector3().subVectors(to, from).normalize();
        bullet.userData = { vel: direction.multiplyScalar(3.0), life: 100 }; // Schnell
        
        scene.add(bullet);
        bullets.push(bullet);
    }

    function updateBullets() {
        for(let i=bullets.length-1; i>=0; i--) {
            const b = bullets[i];
            b.position.add(b.userData.vel);
            b.userData.life--;
            
            // Treffer Check (Spieler)
            if (b.position.distanceTo(playerGroup.position) < 3.0) {
                takeDamage(10);
                scene.remove(b);
                bullets.splice(i, 1);
                continue;
            }

            if(b.userData.life <= 0) {
                scene.remove(b);
                bullets.splice(i, 1);
            }
        }
    }

    function takeDamage(amount) {
        if(isGameOver) return;
        playerHealth -= amount;
        if(playerHealth < 0) playerHealth = 0;
        
        // UI Update
        document.getElementById('hp-fill').style.width = playerHealth + '%';
        // Farbe ändern bei niedrigem Leben
        if(playerHealth < 30) document.getElementById('hp-fill').style.backgroundColor = 'red';
        else document.getElementById('hp-fill').style.backgroundColor = '#00ff00';

        if(playerHealth <= 0) {
            isGameOver = true;
            document.getElementById('gameover').style.display = 'block';
        }
    }

    // --- CAR TO CAR KOLLISION ---
    function checkCarCollisions() {
        const pPos = playerGroup.position;
        const radius = 3.5; // Kollisionsradius

        aiCars.forEach(ai => {
            const dist = pPos.distanceTo(ai.position);
            if (dist < radius) {
                // CRASH!
                
                // 1. Spieler prallt ab
                speed = -speed * 0.8; // Umkehren
                
                // 2. AI wird weggeschleudert
                // Vektor vom Spieler zum AI Auto
                const impactDir = new THREE.Vector3().subVectors(ai.position, pPos).normalize();
                ai.userData.velocity.add(impactDir.multiplyScalar(2.5)); // Starker Impuls
                
                // 3. AI wird AGGRO
                if (ai.userData.state !== 'attack') {
                    ai.userData.state = 'attack';
                    // Auto rot färben als Feedback
                    ai.children[0].traverse(c => {
                        if(c.isMesh && c.material) c.material.color.setHex(0xff0000);
                    });
                }
            }
        });
    }

    function spawnSmoke(pos) {
        if(Math.random()>0.3)return; 
        const p=new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5),new THREE.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.4}));
        p.position.copy(pos); p.position.y=0.2; 
        p.rotation.set(Math.random(), Math.random(), Math.random());
        scene.add(p); particles.push({mesh:p, life:1.0});
    }

    function animate() {
        if(isGameOver) return;
        requestAnimationFrame(animate);

        document.getElementById('speed-text').innerText = Math.abs(Math.floor(speed * 120));
        document.getElementById('pos-text').innerText = `${Math.round(playerGroup.position.x)}, ${Math.round(playerGroup.position.z)}`;

        if (keys.w) speed += acceleration;
        else if (keys.s) speed -= acceleration;
        else speed *= friction;

        if (speed > maxSpeed) speed = maxSpeed;
        if (speed < -0.8) speed = -0.8;

        if (Math.abs(speed) > 0.05) {
            const dir = speed > 0 ? 1 : -1;
            if(keys.a) playerGroup.rotation.y += turnSpeed * dir;
            if(keys.d) playerGroup.rotation.y -= turnSpeed * dir;
        }

        const velocity = new THREE.Vector3(0, 0, -speed).applyAxisAngle(new THREE.Vector3(0,1,0), playerGroup.rotation.y);
        const newPos = playerGroup.position.clone().add(velocity);

        // Kollision Gebäude
        let collision = false;
        const carSize = 2.0; 
        for (let b of colliders) {
            const bMinX = b.x - b.w/2; const bMaxX = b.x + b.w/2;
            const bMinZ = b.z - b.d/2; const bMaxZ = b.z + b.d/2;
            if (newPos.x + carSize > bMinX && newPos.x - carSize < bMaxX && newPos.z + carSize > bMinZ && newPos.z - carSize < bMaxZ) {
                collision = true; break;
            }
        }

        if (collision) { speed = -speed * 0.5; } else { playerGroup.position.copy(newPos); }

        // Car vs Car Check
        checkCarCollisions();

        // Drift
        let targetAngle = 0;
        if (keys.space && Math.abs(speed) > 0.5) {
            if (keys.a) targetAngle = 0.5; else if (keys.d) targetAngle = -0.5;
            tires.forEach(t => { const p=new THREE.Vector3(); t.getWorldPosition(p); spawnSmoke(p); });
            speed *= 0.99;
        }
        currentDriftAngle = THREE.MathUtils.lerp(currentDriftAngle, targetAngle, 0.1);
        carModel.rotation.y = currentDriftAngle;

        updateAI();
        updateBullets();

        const relativeCamOffset = new THREE.Vector3(0, 8, 20); 
        const cameraOffset = relativeCamOffset.applyMatrix4(playerGroup.matrixWorld);
        camera.position.lerp(cameraOffset, 0.1);
        const lookAtTarget = new THREE.Vector3(0, 2, -10); 
        lookAtTarget.applyMatrix4(playerGroup.matrixWorld);
        camera.lookAt(lookAtTarget);

        for(let i=particles.length-1; i>=0; i--) { 
            let p = particles[i]; p.life-=0.02; p.mesh.position.y+=0.05; 
            p.mesh.scale.multiplyScalar(1.05); p.mesh.material.opacity=p.life*0.5; 
            if(p.life<=0){ scene.remove(p.mesh); particles.splice(i,1); }
        }

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
